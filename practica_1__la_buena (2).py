# -*- coding: utf-8 -*-
"""Practica_1_ la_buena.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oxgLZCHVBOB_TL_jqZXj5MEu4lMcz785
"""

import pandas as pd
import numpy as np

class Directed_graph:
    """Clase que no genera un grafica dirigida"""
    def _init_(self):
        self.nodos = [] #generamos listas vacias para que posteriormente guarden a quienes son nuestros nodos
        self.arcos = [] #generamos listas vacias para que posteriormente guarden a quienes son nuestros nodos

    def len_arcos(self):
        """Esta funcion nos dice la longitud de nuestra lista arcos"""
        return len(self.arcos)

    def len_nodos(self):
        """Esta funcion nos dice la longitud de nuestra lista nodos """
        return len(self.nodos)

    def antecesores(self, nodo):
        """Esta funcion checa si el nodo que le dimos esta en lista"""
        if nodo not in self.nodos: #checa si el nodo que le dimos esta en nuestra lista de nodos
            print(nodo, "NO PERTENECE AL CONJUNTO DE NODOS")
            return []
        else:
            ant = []
            for x in self.arcos: #guardaremos el antecesor en el indice correspondiente
                if nodo == x[-1]:
                    ant.append(x[0])
            return ant

    def sucesor(self, nodo):
        """Esta funcion checa si el sucesor que le dimos esta en lista"""
        if nodo not in self.arcos:  #checa si el arco que le dimos esta en nuestra lista de nods
            print(nodo, "No pertenece al conjunto de nodos")
            return []
        else:
            ant = []
            for x in self.arcos: #guardaremos el sucesor en el indice correspondiente
                if nodo == x[0]:
                    ant.append(x[-1])
            return ant

    def add_vertex(self, nodo):
        """Funcion que crea al nodo"""
        self.nodos.append(nodo)

    def add_arc(self, arco):
        """Funcion que crea al arco"""
        if isinstance(arco, tuple) and len(arco) == 3: #le preguntamos si arco es una tupla
            if arco[0] in self.nodos and arco[1] in self.nodos:
                self.arcos.append(arco)
            else:
                print("LAS ENTRADAS NO PERTENECEN A LOS NODOS")
        else:
            print("EL ARCO NO ES VALIDO")

def leer_archivo(arch_excel):
  """Funcion que nos da los datos de un excel"""
  arch = pd.read_excel(arch_excel)
  return arch

def extraer_columnas(datos):
  """"Funcion que me extrae los datos pero se va fijando en las columnas"""
  actividades = datos["Actividad"] #guarda los datos de la columna llamada Actividad de nuestro excel
  precedentes = datos["Precedentes"] #guarda los datos de la columna llamada Precedentes de nuestro excel
  duracion = datos["Duracion"] #guarda los datos de la columna llamada Duracion de nuestro excel
  return actividades, precedentes, duracion


def crear_tupla(act,prec, dur ):
  """Funcion que me genera una lista de tuplas que contienen (actividad, precedentes, duracion)"""
  tupla = []
  pre = []
  for i in range(len(act)): #Le digo que lo repita el numero de veces de la longitud de act
    if isinstance(prec[i], str): #Le pregunto si el elemento de precedentes en la posicion i es una cadena
        tupla_entero= tuple(int(x) for x in prec[i].split(",")) #le digo que lo divida, que lo convierta a enteros y luego en una tupla
        tupla.append((act[i],tupla_entero,dur[i])) # le digo que me lo guarde en una tupla
    elif isinstance(prec[i],float): #Le pregunto si el elemento de precedentes en la posicion i es un flotante
      prec[i]= (0) # le digo que le asigne el 0
      tupla.append((act[i], tuple((prec[i],)), dur[i])) # le digo que me lo guarde en una tupla
    else:
      tupla.append((act[i], tuple((prec[i],)),dur[i])) # le digo que me lo guarde en una tupla
  return tupla

def ordenar_tupla (l):
  """Funcion que me ordena a la tupla de acuerdo a sus precedentes es decir cuando su precedentes ya estan definidos"""
  precedentes = [0]
  ruta= []
  precedentes_no_definidos = []
  dur = []
  act=[]
  prec=[]
  for i in l:
      max_elemento_tupla = max(i[1]) #le digo que me guarde al maximo de los elementos
      if max_elemento_tupla in precedentes: #le pregunto si este maximo ya esta definido
        precedentes.append(i[0]) #agrego la actividad que se acaba de definir a los precedentes
        ruta.append(i) #lo agrego a la ruta
      else:
        precedentes_no_definidos.append(i) #lo agrego a la precedentes_no_definidos



  while precedentes_no_definidos: #mientras la lista de precedentes_no_definidos tenga algun elemento
    elem = precedentes_no_definidos[0]
    tupla_precedentes = elem[1]
    max_elemento_tupla = max(tupla_precedentes) # calcula al maximo de sus precedentes
    if max_elemento_tupla in precedentes:#veo si ya esta su maximo en precedentes
      precedentes.insert(precedentes.index(max_elemento_tupla)+1, elem[0]) #que lo agregue en el indice de la actividad maxima +1
      precedentes_no_definidos.pop(0) #que borre al primero
      ruta.insert(precedentes.index(max_elemento_tupla), elem) #que lo agregue a ruta

    else:
      precedentes_no_definidos.pop(0)
      precedentes_no_definidos.append(elem)

  for i in ruta:
      dur.append(i[2]) #me guarda la lista de duracion pero ya ordenada
      act.append(i[0])#me guarda la lista de actividades pero ya ordenada
      prec.append(i[1])#me guarda la lista de precedentes pero ya ordenada
  return dur,act,ruta,prec

def fecha_mas_proximas(ruta,dur,prec,act):
  """Funcion que me calcula las fechas mas proximas"""
  act.insert(0,0)
  #ruta = [(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (18, (15,), 3), (16, (12, 13, 18), 15), (17, (9, 16), 10), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
  #dur = [3, 15, 10, 2, 8, 10, 10, 8, 5, 20, 10, 8, 6, 10, 20, 3, 15, 10, 8, 8, 8]
  #prec = [(0,), (1,), (2,), (3,), (4,), (4,), (4,), (4,), (4,), (5,), (6,), (7,), (8,), (11,), (10, 14), (15,), (12, 13, 18), (9, 16), (18,), (17, 19), (20,)]
  #act = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21]
  fecha_mas_proxima = [0]
  # Calcula todas las fechas más próximas
  for i in range(len(act) - 1): #le digo que la repita el numero de veces de la longitud de actividades -1
      if len(prec[i]) == 1: #le pregunto si la longitud de la tupla donde estan los precedentes es 1
          Fmpi = fecha_mas_proxima[act.index(prec[i][0])] + dur[i] #solo contemplo el caso donde es uno por eso no saco el maximo
          fecha_mas_proxima.append(Fmpi)
      else:
          max_prec = max(fecha_mas_proxima[act.index(p)] + dur[i] for p in prec[i]) # contemplo el caso donde es mas de uno por eso saco el maximo
          Fmpi = max_prec
          fecha_mas_proxima.append(Fmpi)

  for i in ruta:
      pred = i[1]
      if len(pred) > 1:
          fecha_i = []
          for j in pred:
              index = act.index(j)
              fecha_i.append(fecha_mas_proxima[index])
          maximos = max(fecha_i)
          for j in pred:
              fecha_mas_proxima[act.index(j)] = maximos

  return(fecha_mas_proxima)

def crear_lista_sucesores(prec,act):
  """Funcion que me crea a la lista de sucesores"""
  #prec = [(0,), (1,), (2,), (3,), (4,), (4,), (4,), (4,), (4,), (5,), (6,), (7,), (8,), (11,), (10, 14), (15,), (12, 13, 18), (9, 16), (18,), (17, 19), (20,)]
  #act = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21]
  sucesores=[]

  for i in range(len(act)):
      sucesor_i = []
      for j in range(len(prec)-1):
          if i in prec[j+1]:
              sucesor_i.append(j+1)  # Sumar 1 a cada elemento
      sucesores.append(tuple(sucesor_i))
  sucesores[-1] = (len(prec),)
  sucesores[0] = (1,)
  sucesores.insert(0,(0,))
  return(sucesores)

def preparar_lista_para_fecha_mas_lejana(act,dur):
  """Funcion que me ordena las lista para que las pueda usar en la funcion fecha_mas_lejana"""
  #act = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21, 22]
  act.append(len(act))
  r=list(reversed(act)) #me invierte la lista

  print(r)

  #prec= [(1,), (2,), (3,), (4,), (5,6,7,8,9), (10,), (11,), (12,), (13,), (0,), (15,), (14,), (16,), (16, ), (15,), ( 18,), ( 16,19), (17,), (20, ), (21,) , (22,)]
  #p=list(reversed(prec))
  #print(p)

  #dur = [3, 15, 10, 2, 8, 10, 10, 8, 5, 20, 10, 8, 6, 10, 20, 3, 15, 10, 8, 8, 8, 0]
  dur.append(0)
  d=list(reversed(dur)) #me invierte la lista
  print(d)

  return r,d

def fecha_mas_lejana(d,r,fecha_mas_proxima):
  """Funcion que calcula la fecha mas lejana"""
  #d = [0, 8, 8, 8, 10, 15, 3, 20, 10, 6, 8, 10, 20, 5, 8, 10, 10, 8, 2, 10, 15, 3]
  s = [ (22,) ,(21,),(20,), (20,), (17,), (16, 19), (18,), (15,), (16,), (16,), (14,), (15,), (17,), (13,), (12,), (11,), (10,), (5, 6, 7, 8, 9), (4,), (3,), (2,), (1,), (0,)]
  #r = [ 22, 21, 20, 19, 17, 16, 18, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  #fecha_mas_proxima = [0, 3, 18, 28, 30, 38, 40, 40, 38, 98, 60, 50, 83, 83, 60, 80, 83, 98, 108, 108, 116, 124]
  for i in range(1, len(r)):
      suc_i = s[i-1]
      fecha_i=[]
      for j in suc_i:
        FML_j=fecha_mas_lejana[r.index(j)]
        dur_j = d[r.index(j)]
        fecha_j = FML_j - dur_j
        fecha_i.append(fecha_j)
      min_i = min(fecha_i)
      fecha_mas_lejana.append(min_i)
  return fecha_mas_lejana


def calcular_rutas_criticas(FML,FMP,dur,act):
  """Funcion que calcula las fechas criticas"""
  #FML =[ 124, 116, 108, 108, 98, 83, 80, 60, 83, 83, 50, 60, 98, 77, 75, 40, 40, 30, 28, 18, 3,0]
  #FMP= [0, 3, 18, 28, 30, 38, 40, 40, 38, 98, 60, 50, 83, 83, 60, 80, 83, 98, 108, 108, 116, 124]
  #dur=[3, 15, 10, 2, 8, 10, 10, 8, 5, 20, 10, 8, 6, 10, 20, 3, 15, 10, 8, 8, 8]
  #act = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21,0]
  rutas_criticas=[]
  FMP_FML=[]
  Holguras=[]
  fml= list(reversed(FML))

  for i in range(len(dur)):
      holgura_i= FMP[i+1]- fml[i] -dur[i]
      Holguras.append(holgura_i)

  for i, holgura in enumerate(Holguras):
      if holgura == 0:
          rutas_criticas.append(act[i]+1)

  return rutas_criticas

def crear_diccionario(l):
  """Funcion que genera un diccionario de acuerdo a la tupla que creamos al inicio"""
#l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (18, (15,), 3), (16, (12, 13, 18), 15), (17, (9, 16), 10), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
  dic = {}
  for i in l:
      if max(i[1]) == 0:
          dic.update({i[0]: []})
      else:
          dic.update({i[0]: list(i[1])})
  return dic

def crear_grafica(dic):
  """Funcion que nos va crear la grafica"""
  #dic = {1: [], 2: [1], 3: [2], 4: [3], 5: [4], 6: [4], 7: [4], 8: [4], 9: [4], 10: [5], 11: [6], 12: [7], 13: [8], 14: [11], 15: [10, 14], 18: [15], 16: [12, 13, 18], 17: [9, 16], 19: [18], 20: [17, 19], 21: [20]}
  sub = {}
  arcs = {}
  nodos = [0,1]
  done = [[],[]]
  ind= 2
  arrows = []
  arcs = {}
  for a, ps in dic.items():
    sub[a] = []
    for p in ps:
      sub[p].append(a)

  for k,v in dic.items():
    if v == []:
      nodos.append(ind)
      arrows.append((0, ind))
      done.append([k])
      arcs[k] = (0,ind)
      ind += 1
    elif not v in done:
      separated = [[elem] for elem in v ]
      for elem in separated:
        arrows.append((done.index(elem), ind))
      done.append(v)
      nodos.append(ind)
      ind += 1
      if sub[k] == []:
        arrows.append((done.index(v),1))
        arcs[k] = (done.index(v), 1)
      else:
          nodos.append(ind)
          arrows.append((done.index(v), ind))
          done.append([k])
          arcs[k] = (done.index(v, 1))
          ind += 1
    else:
        if sub[k] == []:
          arrows.append((done.index(v), 1))
          arcs[k] = (done.index(v),1)
        else:
          nodos.append(ind)
          arrows.append((done.index(v), ind))
          done.append([k])
          arcs[k] = (done.index(v), ind)
          ind += 1
  return nodos, arcs



def main():
  #recuperar datos
  infile = '/content/Creacion_de_la_carrera_de_mat_ap.xlsx'
  datos = leer_archivo(infile)
  act, prec, dur = extraer_columnas(datos)
  l = crear_tupla(act,prec,dur)
  dur, act, ruta, prec = ordenar_tupla(l)
  fecha_mas_proxima = fecha_mas_proximas(ruta,dur,prec,act)
  suc = crear_lista_sucesores(prec,act)
  r,d = preparar_lista_para_fecha_mas_lejana(act,dur)
  fecha_mas_lejanas= fecha_mas_lejana(d,r,fecha_mas_proxima)
  rutas_criticas = calcular_rutas_criticas(fecha_mas_lejanas, fecha_mas_proxima, dur, act)

  FML =[ 124, 116, 108, 108, 98, 83, 80, 60, 83, 83, 50, 60, 98, 77, 75, 40, 40, 30, 28, 18, 3,0]
  FMP= [0, 3, 18, 28, 30, 38, 40, 40, 38, 98, 60, 50, 83, 83, 60, 80, 83, 98, 108, 108, 116, 124]
  dur=[3, 15, 10, 2, 8, 10, 10, 8, 5, 20, 10, 8, 6, 10, 20, 3, 15, 10, 8, 8, 8]
  act = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21,0]
  rutas_criticas=[]
  FMP_FML=[]
  Holguras=[]
  fml= list(reversed(FML))

  for i in range(len(dur)):
      holgura_i= FMP[i+1]- fml[i] -dur[i]
      Holguras.append(holgura_i)

  for i, holgura in enumerate(Holguras):
      if holgura == 0:
          rutas_criticas.append(act[i]+1)
  print(rutas_criticas)



main()

def ordenar_tupla (l):
#l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (16, (12, 13, 18), 15), (17, (9, 16), 10), (18, (15,), 3), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
  precedentes = [0]
  ruta= []
  precedentes_no_definidos = []
  dur = []
  act=[]
  for i in l:
      max_elemento_tupla = max(i[1])
      if max_elemento_tupla in precedentes:
        precedentes.append(i[0])
        ruta.append(i)
      else:
        precedentes_no_definidos.append(i)



  while precedentes_no_definidos:
    elem = precedentes_no_definidos[0]
    tupla_precedentes = elem[1]
    max_elemento_tupla = max(tupla_precedentes)
    if max_elemento_tupla in precedentes:
      precedentes.insert(precedentes.index(max_elemento_tupla)+1, elem[0])
      precedentes_no_definidos.pop(0)
      ruta.insert(precedentes.index(max_elemento_tupla), elem)

    else:
      precedentes_no_definidos.pop(0)
      precedentes_no_definidos.append(elem)

  for i in ruta:
      dur.append(i[2])
      act.append(i[0])
  return dur,act,ruta

l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (16, (12, 13, 18), 15), (17, (9, 16), 10), (18, (15,), 3), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]

def crear_ruta(l):
  precedentes = [0]
  ruta= []
  precedentes_no_definidos = []
  for i in l:
    max_elemento_tupla = max(i[1])
    if max_elemento_tupla in precedentes:
      precedentes.append(i[0])
      ruta.append(i)
    else:
      precedentes_no_definidos.append(i)

  while precedentes_no_definidos:
    elem = precedentes_no_definidos[0]
    tupla_precedentes = elem[1]
    max_elemento_tupla = max(tupla_precedentes)
    if max_elemento_tupla in precedentes:
      precedentes.insert(precedentes.index(max_elemento_tupla)+1, elem[0])
      precedentes_no_definidos.pop(0)
      ruta.insert(precedentes.index(max_elemento_tupla), elem)

    else:
      precedentes_no_definidos.pop(0)
      precedentes_no_definidos.append(elem)
  return ruta

ruta= (crear_ruta(l))
precedentes=[]
dur=[]
act =[]
for i in ruta:
  precedentes.append(i[1])
  dur.append(i[2])
  act.append(i[0])

print(ruta)
print(dur)
print(precedentes)
print(act)

precedentes_repetidos= [4, 4, 4, 4, 4, 18, 18]
l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (16, (12, 13, 18), 15), (17, (9, 16), 10), (18, (15,), 3), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
def checar_precedentes_repetidos(tupla):
  precedentes_repetidos=[]
  tuplas_con_precedentes_distintos= []
  tuplas_con_precedentes_iguales= []
  precedentes=[]
  for i in l:
    max_1= max(i[1])
    if max_1 not in precedentes:
      precedentes.append(max_1)
      tuplas_con_precedentes_distintos.append(i)
    else:
      precedentes_repetidos.append(max_1)
      tuplas_con_precedentes_iguales.append(i)
      precedentes.append(max_1)

  for x in tuplas_con_precedentes_distintos:
    max_1= max(x[1])
    if max_1 in precedentes_repetidos:
      precedentes_repetidos.append(max_1)
      precedentes_repetidos = sorted(precedentes_repetidos, key=lambda x: x)
      tuplas_con_precedentes_distintos.remove(x)
      tuplas_con_precedentes_iguales.append(x)
      tuplas_con_precedentes_iguales = sorted(tuplas_con_precedentes_iguales, key=lambda x: x[0])
  return tuplas_con_precedentes_iguales, precedentes_repetidos


def fecha_mas_proxima(precedentes_repetidos,tupla):

  FMPi = 0 #fecha mas proxima del anterior
  FMPJ = [0]
  tuplas_con_mismos_precedentes=[]
  precedentes=[0]

  for i in range(len(tupla)):
    max_2 = max(tupla[i][1])  # Find the maximum value in the second element of the current tuple
    dur = tupla[i][2]
    if max_2 in precedentes_repetidos:
      if max_2 == max(tupla[i][1]):
        checar_max = max(FMPi + dur, FMPi +dur)
        FMPi=checar_max
        FMPJ.append(checar_max)
  else:
    if l[i-1][1] != l[i][1]:
      FMPj = FMPi + l[i][2]#fecha mas proxima del actual
      FMPi= FMPj
      FMPJ.append(FMPi)
    else:
      FMPj = max(FMPi, FMPi + l[i][2])#fecha mas proxima del actual
      FMPi= FMPj
      FMPJ.append(FMPi)



print(fecha_mas_proxima( precedentes_repetidos, l))
print(checar_precedentes_repetidos(l))

precedentes_repetidos= [4, 4, 4, 4, 4, 18, 18]
precedentes = [0, 1, 2, 3, 4, 4, 4, 4, 4, 5, 6, 7, 8, 11, 14, 18, 16, 15, 18, 19, 20]
dur=[3, 15, 10, 2, 8, 10, 10, 8, 5, 20, 10, 8, 6, 10, 20, 3, 15, 10, 8, 8, 8]
act=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18, 16, 17, 19, 20, 21]
FMPJ=[0]
FMPj = 0
x=0
fecha_mas_proxima = [0]
for i in range(len(act)-1):
      if precedentes[i] in precedentes_repetidos:
        if precedentes[i] == precedentes_repetidos[x]:
            x +=1
            checar_max = max(fecha_mas_proxima[act.index(precedentes[i])] + dur[act.index(precedentes[i])], fecha_mas_proxima[act.index(precedentes[x])] + dur[act.index(precedentes[x])])
            fecha_mas_proxima.append(checar_max)
        else:
          FMPJ.append(checar_max)
          fecha_mas_proxima.append(checar_max)
      else:
            if precedentes[i] == 0:
              Fmpj = FMPj + dur[0]
              FMPJ.append(Fmpj)
              fecha_mas_proxima.append(Fmpj)
            else:
              index= act.index(precedentes[i])
              print(index)
              Fmpj = fecha_mas_proxima[index+1]+ dur[index+1]
              FMPJ.append(Fmpj)
              fecha_mas_proxima.append(Fmpj)
              print(FMPJ)
print(fecha_mas_proxima)

precedentes_repetidos= [4, 4, 4, 4, 4, 18, 18]
FMPJ =[]
FMPj = 0
FMPi = 0
fecha_mas_proxima = [0]
tupla =
for i in tupla:
  max_elemento_tupla = max(i[1])
  if max_elemento_tupla in precedentes_repetidos:
      if max_2 in precedentes_repetidos:
        if max_2 == precedentes_repetidos.index(max_elemento_tupla)+1:
            checar_max = max(fecha_mas_proxima[max_2] + tupla[i][2], fecha_mas_proxima[i+1] + tupla[i][2])
            fecha_mas_proxima.append(checar_max)
        else:
          FMPJ.append(checar_max)
  else:
    checar_max = fecha_mas_proxima[max_2] + i[2]
    fecha_mas_proxima.append(checar_max)
    FMPJ.append(checar_max)

tupla=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (18, (15,), 3), (16, (12, 13, 18), 15), (17, (9, 16), 10), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
precedentes_repetidos= [4, 4, 4, 4, 4, 18, 18]
FMPJ =[0]
FMPj = 0
FMPi = 0
x=0
y=0
fecha_mas_proxima = [0]

for i in tupla:
  max_precedente = max(i[1])
  if max_precedente in precedentes_repetidos:
    if max_precedente == precedentes_repetidos[x]:
      x +=1
      checar_max = max(FMPJ[x] + i[2] , FMPJ[x+1] + i[2])
      fecha_mas_proxima.append(checar_max)
    else:
      FMPJ.append(checar_max)
  else:
    checar_max = max(FMPJ[x] + i[2] , FMPJ[x+1] + i[2])
    FMPJ.append(checar_max)
    fecha_mas_proxima.append(checar_max)

def crear_diccionario(l):
#l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (18, (15,), 3), (16, (12, 13, 18), 15), (17, (9, 16), 10), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
  dic = {}
  for i in l:
      if max(i[1]) == 0:
          dic.update({i[0]: []})
      else:
          dic.update({i[0]: list(i[1])})
  return dic

#l=[(1, (0,), 3), (2, (1,), 15), (3, (2,), 10), (4, (3,), 2), (5, (4,), 8), (6, (4,), 10), (7, (4,), 10), (8, (4,), 8), (9, (4,), 5), (10, (5,), 20), (11, (6,), 10), (12, (7,), 8), (13, (8,), 6), (14, (11,), 10), (15, (10, 14), 20), (18, (15,), 3), (16, (12, 13, 18), 15), (17, (9, 16), 10), (19, (18,), 8), (20, (17, 19), 8), (21, (20,), 8)]
#CLC =[]
#for i in l:
    #CLC.append((i[0], i[2]))
#print(CLC)

def crear_grafica(dic):
  #dic = {1: [], 2: [1], 3: [2], 4: [3], 5: [4], 6: [4], 7: [4], 8: [4], 9: [4], 10: [5], 11: [6], 12: [7], 13: [8], 14: [11], 15: [10, 14], 18: [15], 16: [12, 13, 18], 17: [9, 16], 19: [18], 20: [17, 19], 21: [20]}
  sub = {}
  arcs = {}
  nodos = [0,1]
  done = [[],[]]
  ind= 2
  arrows = []
  arcs = {}
  for a, ps in dic.items():
    sub[a] = []
    for p in ps:
      sub[p].append(a)

  for k,v in dic.items():
    if v == []:
      nodos.append(ind)
      arrows.append((0, ind))
      done.append([k])
      arcs[k] = (0,ind)
      ind += 1
    elif not v in done:
      separated = [[elem] for elem in v ]
      for elem in separated:
        arrows.append((done.index(elem), ind))
      done.append(v)
      nodos.append(ind)
      ind += 1
      if sub[k] == []:
        arrows.append((done.index(v),1))
        arcs[k] = (done.index(v), 1)
      else:
          nodos.append(ind)
          arrows.append((done.index(v), ind))
          done.append([k])
          arcs[k] = (done.index(v, 1))
          ind += 1
    else:
        if sub[k] == []:
          arrows.append((done.index(v), 1))
          arcs[k] = (done.index(v),1)
        else:
          nodos.append(ind)
          arrows.append((done.index(v), ind))
          done.append([k])
          arcs[k] = (done.index(v), ind)
          ind += 1
  return nodos, arcs